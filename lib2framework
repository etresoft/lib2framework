#!/usr/bin/perl

use strict;

use Cwd;
use File::Spec;
use File::Basename;
use File::Copy;
use File::Spec;
use Getopt::Long qw(:config bundling pass_through);

# Print usage message if there aren't enough arguments to run.
die usage()
  if @ARGV < 4;

# Get the framework name to build.
my $framework = shift;

# Get the org.project.whatever ID.
my $id = shift;

# Get the version.
my $version = shift;

# Get the archive to build.
my $archive = shift;

# Get optional arguments.
my $installPath;
my $sdk;
my $deployment;
my $target;
my $debug;

GetOptions
  (
  'frameworkInstallPath=s' => \$installPath,
  'sdk=s' => \$sdk,
  'deploy=s' => \$deployment,
  'target=s' => \$target,
  'debug' => \$debug
  );
  
my $dir;

# If the archive is a directory, copy it to /tmp to work on it.
if(-d $archive)
  {
  $dir = File::Spec->join('/tmp', $archive);
  
  runsystem(qq{/bin/rm -Rf "$dir"});
  runsystem(qq{/bin/cp -R "$archive" "$dir"});
  }
elsif($archive =~ /\.tgz|\.tar\.gz$/)
  {
  runsystem(qq{/bin/rm -Rf "/tmp/$archive"});
  runsystem(qq{/bin/mkdir -p "/tmp/$archive"});
  runsystem(qq{/usr/bin/tar zxf "$archive" -C/tmp/$archive});
  
  $dir = `/usr/bin/find /tmp/$archive -mindepth 1 -maxdepth 1`;
  
  chomp $dir;
  }
elsif($archive =~ /\.tbz|\.tar\.bz$/)
  {
  runsystem(qq{/bin/rm -Rf "/tmp/$archive"});
  runsystem(qq{/bin/mkdir -p "/tmp/$archive"});
  runsystem(qq{/usr/bin/tar jxf "$archive" -C/tmp/$archive});
  
  $dir = `/usr/bin/find /tmp/$archive -mindepth 1 -maxdepth 1`;
  
  chomp $dir;
  }
  
# Set a default framework install path.
my $defaultInstallPath = File::Spec->join($ENV{HOME}, 'Library/Frameworks');

# Default to ~/Library/Frameworks
$installPath = $defaultInstallPath
  if not $installPath;

# Set a default SDK.
$sdk = 'macosx'
  if not $sdk;

# Set a default deployment.  
if(not $deployment)
  {
  $deployment = `xcrun --sdk $sdk --show-sdk-version`;

  chomp $deployment;
  }
  
# Setup the SDKROOT. Hopefully this will handle most situations.
$ENV{SDKROOT} = `/usr/bin/xcrun --sdk $sdk --show-sdk-path`;
  
chomp $ENV{SDKROOT};

# Get any other options.
my @args = @ARGV;

# Setup some command line arguments in case I need them.
my @arch;
my $minversion = '';

# Configure for iPhone.
if($sdk =~ /^iphoneos/i)
  {
  @arch = qw(armv7 armv7s arm64);

  $minversion = sprintf('-miphoneos-version-min=%s', $deployment);
    
  $ENV{IPHONEOS_DEPLOYMENT_TARGET} = $deployment;
  
  push @args, qw(--build=x86_64-apple-darwin12 --host=arm-apple-darwin10)
  }
  
# Configure for iPhone simulator.
elsif($sdk =~ /^iphonesimulator/i)
  {
  @arch = qw(i386 x86_64);

  $minversion = sprintf('-mios-simulator-version-min=%s', $deployment);

  $ENV{IPHONEOS_DEPLOYMENT_TARGET} = $deployment;
  }
  
# Configure for MacOS X.
elsif($sdk =~ /^macosx/i)
  {
  my ($version) = $sdk =~ /^macosx(.+)$/i;
  
  @arch = qw(i386 x86_64);
    
  $minversion = sprintf('-mmacosx-version-min=%s', $deployment);

  $ENV{MACOSX_DEPLOYMENT_TARGET} = $deployment;
  }

# Tack on a horrible path for platform and SDK-specific frameworks.
my @parts = split /\//, $ENV{SDKROOT};
my @dirParts = @parts[4..9];

$installPath = 
  File::Spec->join(
    $installPath, @dirParts, 'Frameworks')
  if $installPath ne $defaultInstallPath;
  
# Setup the isysroot command-line parameters and PATH, if necessary.
$ENV{PATH} = sprintf(
  '%s:%s:/usr/bin:/bin:/usr/sbin:/sbin',
  $ENV{SDKROOT},
  "/Applications/Xcode.app/Contents/Developer/usr/bin")
if $sdk && ($sdk =~ /^iphone/i);
  
my $xargs = 
  {
  framework => $framework,
  source => $dir,
  id => $id,
  sdk => $sdk,
  minversion => $minversion,
  frameworkPath =>     
    File::Spec->join($installPath, sprintf('%s.framework', $framework))
  };

# Create a full install directory tree.

# Give me one iteration at least.
@arch = qw(x86_64)
  if not @arch;
  
my @archList = map { '-arch ' . $_ } @arch;

# Now hack up the version for non-native builds.
$xargs->{version} = $version;

$ENV{CFLAGS} = "@archList -isysroot $ENV{SDKROOT} $minversion";
$ENV{CXXFLAGS} = "@archList -isysroot $ENV{SDKROOT} $minversion";

# Create the framework bones.
createFramework($xargs);

# Now build the UNIX project.
buildProject($xargs, @args);

# Turn the library into a framework.
convertToFramework($xargs);

# Install the final framework.
installFramework($xargs);
  
# Create framework bones.
sub createFramework
  {
  my $xargs = shift;

  my $frameworkPath = $xargs->{frameworkPath};

  my $frameworkVersionPath = 
    File::Spec->join($frameworkPath, 'Versions', $xargs->{version});

  mkpath("$frameworkVersionPath/Headers");
  mkpath("$frameworkVersionPath/Programs");
  mkpath("$frameworkVersionPath/Resources/Engish.lproj");
  mkpath("$frameworkVersionPath/unix/lib");

  # Now create some symbolically linked directories.
  symlink "../Headers", "$frameworkVersionPath/unix/include";
  symlink "../Programs", "$frameworkVersionPath/unix/bin";
  symlink "../Resources", "$frameworkVersionPath/unix/share";
  }

# Build a UNIX project in the unix directory of the framework.
sub buildProject
  {
  my $xargs = shift;
  my @args = @_;

  my $frameworkPath = $xargs->{frameworkPath};

  my $frameworkVersionPath =  
    "$frameworkPath/Versions/" . $xargs->{version};

  runsystem(qq{/bin/rm -Rf "$frameworkVersionPath"});

  runsystem(qq{/bin/mkdir -p "$frameworkVersionPath/unix"});

  my $prefix = File::Spec->rel2abs("$frameworkVersionPath/unix");

  # Move into the directory.
  chdir $xargs->{source};

  # If there is a configure script, pass the args to it.
  if(-e 'configure')
    {
    runsystem(qq{./configure --prefix=$prefix @args});

    # Make sure we get a fresh build.
    runsystem("make clean");

    # Build using the provided arguments. If there was a configure script,
    # the argument list will be empty.
    runsystem("make");

    # Now install into the framework.
    runsystem("make install");
    
    # Do a custom build.
    runsystem("make $target")
      if $target;
    }
  else
    {
    # Make sure we get a fresh build.
    runsystem("make @args clean");

    # Build using the provided arguments. If there was a configure script,
    # the argument list will be empty.
    runsystem("make @args");

    # Now install into the framework.
    runsystem("make @args install");

    # Do a custom build.
    runsystem("make @args $target")
      if $target;
    }

  chdir "..";
  }

# Turn a library into a framework.
sub convertToFramework
  {
  my $xargs = shift;
  my @args = @_;

  my $frameworkPath = $xargs->{frameworkPath};

  my $frameworkVersionPath = 
    "$frameworkPath/Versions/" . $xargs->{version};

  my $prefix = File::Spec->rel2abs("$frameworkVersionPath/unix");

  # Establish the library file and links to it.

  # First I have to find the library.
  my $library;

  # Scan through the UNIX output lib directory.
  opendir(DIR, "$prefix/lib");

  while (defined(my $file = readdir(DIR)))
    {
    # Skip parent and self directory entries.
    next
      if $file =~ /^\.\.?$/;

    # Delete .la files.
    #unlink "$prefix/lib/$file"
    #  if $file =~ /\.la$/;

    # Skip anything that isn't a dynamic library.
    next
      if $file !~ /\.dylib$/;

    # Skip symbolic links.
    next
      if -l "$prefix/lib/$file";

    # Save the library. I assume there will only be one non-link library.
    $library = "$prefix/lib/$file";
    }

  closedir(DIR);

  if($library)
    {
    # Move the library to the framework location.
    rename $library, "$frameworkVersionPath/" . $xargs->{framework};

    # Re-create the library as a symbolic link.
    $library = basename($library);

    symlink 
       "../../" . $xargs->{framework}, 
       "$frameworkVersionPath/unix/lib/$library";
    }
  }

# Install the framework
sub installFramework
  {
  my $xargs = shift;
  my @args = @_;

  my $frameworkPath = $xargs->{frameworkPath};

  # Create or update the Current links.
  setCurrentLink($frameworkPath);

  my $frameworkVersionPath = 
    "$frameworkPath/Versions/" . $xargs->{version};
  
  # Create framework resources.
  createResources(
    $xargs->{framework}, 
    $frameworkVersionPath, 
    $xargs->{version}, 
    $xargs->{id});  
  }
  
# Setup the Current links.
sub setCurrentLink
  {
  my $frameworkPath = shift;
  
  my $frameworkVersionsPath = "$frameworkPath/Versions";

  # Should I update the current link?
  opendir(DIR, $frameworkVersionsPath);

  my $latestVersion;
  
  while (defined(my $existingVersion = readdir(DIR)))
    {
    debug("Current latest version: $latestVersion\n");
    debug("Found existing version: $existingVersion\n");
    # Skip parent and self directory entries.
    next
      if $existingVersion =~ /^Current|\.\.?$/;

    $latestVersion = maxVersion($existingVersion, $latestVersion);
    debug("Set latest version: $latestVersion\n");
    }

  closedir(DIR);

  die "Couldn't find latest version\n"
    if not $latestVersion;
    
  my $frameworkVersionPath = "$frameworkVersionsPath/$latestVersion";
  
  mkpath("$frameworkVersionPath/Resources");
  
  # Create the current symbolic linked directory.
  unlink "$frameworkVersionsPath/Current";

  symlink $frameworkVersionPath, "$frameworkVersionsPath/Current";
  
  symlink "$frameworkVersionPath/$framework", "$frameworkPath/$framework";
  symlink "$frameworkVersionPath/Resources", "$frameworkPath/Resources";
  
  symlink "$frameworkVersionPath/unix/include", "$frameworkPath/Headers"
    if -d "$frameworkVersionPath/unix/include";
  }

# Find the maximum of two version number strings.
sub maxVersion
  {
  my $value1 = shift;
  my $value2 = shift;

  my @value1 = $value1 =~ /(\d+)/g;
  my @value2 = $value2 =~ /(\d+)/g;

  my $index = 0;

  my @max = @value1;

  while(1)
    {
    last
      if not defined $value1[$index];
    
    last
      if not defined $value2[$index];

    if($value1[$index] > $value2[$index])
      {
      @max = @value1;
    
      last;
      }
    elsif($value2[$index] > $value1[$index])
      {
      @max = @value2;
    
      last;
      }
    else
      {
      ++$index;
    
      next;
      }
    }
  
  my $max = join('.', @max);

  return $max;
  }
  
# Create framework resources.
sub createResources
  {
  my $frameworkName = shift;
  my $frameworkVersionPath = shift;
  my $version = shift;
  my $id = shift;

  # Almost done - create the Info.plist file.

  open(OUT, ">$frameworkVersionPath/Resources/Info.plist");

  print OUT getPlist($frameworkName, $version, $id);

  close(OUT);

  # Finally, look for a license file.
  my $license;

  # Scan through the source directory.
  opendir(DIR, "$dir");

  while(defined(my $file = readdir(DIR)))
    {
    # Skip parent and self directory entries.
    next
      if $file =~ /^\.\.?$/;

    # Get the GNU-stye COPYING file.
    $license = $file
      if $file =~ /^COPYING$/;

    $license = $file
      if $file =~ /license/i;

    last
      if $license;
    }

  closedir(DIR);

  copy
    "$dir/$license", "$frameworkVersionPath/Resources/License.txt"
    if $license;
  }

# Construct and return a plist file.
sub getPlist
  {
  my $frameworkName = shift;
  my $version = shift;
  my $id = shift;

  my $plist = << "EOF";
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>English</string>
	<key>CFBundleExecutable</key>
	<string>$frameworkName</string>
	<key>CFBundleGetInfoString</key>
	<string>$framework $version</string>
	<key>CFBundleIdentifier</key>
	<string>$id</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$frameworkName</string>
	<key>CFBundlePackageType</key>
	<string>FMWK</string>
	<key>CFBundleShortVersionString</key>
	<string>$version</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>$frameworkName $version</string>
</dict>
</plist>
EOF

  return $plist;
  }

sub mkpath
  {
  my $dir = shift;

  runsystem(qq{/bin/mkdir -p "$dir"});
  }

sub debug
  {
  my @args = @_;
  
  print("@args\n")
    if $debug;
  }
  
sub runsystem
  {
  debug(@_);
    
  system(@_);
  }
  
# Print usage messages.
sub usage
  {
  my $message = << "EOF";
Usage: lib2framework <framework> <id> <version> <dir> [options]

  where options are:
    --frameworkInstallPath=/path/to/install/location
    --sdk=<SDK in xcrun nomenclature. e.g. macosx, iphonesimulator6.1, etc.>
    --deploy=<minimum OS version>
    --target=<makefile target>
    --debug For debugging statements
    
  Remaining options are passed to configure script.
EOF

  return $message;
  }
  