#!/usr/bin/perl

use strict;

use Cwd;
use File::Spec;
use File::Basename;
use File::Copy;
use File::Spec;
use Getopt::Long qw(:config bundling pass_through);

# Print usage message if there aren't enough arguments to run.
die usage()
  if @ARGV < 4;

# Get the framework name to build.
my $framework = shift;

# Get the org.project.whatever ID.
my $id = shift;

# Get the version.
my $version = shift;

# Get the archive to build.
my $archive = shift;

my $dir;

# If the archive is a directory, copy it to /tmp to work on it.
if(-d $archive)
  {
  $dir = File::Spec->join('/tmp', $archive);
  
  system(qq{/bin/rm -Rf "$dir"});
  system(qq{/bin/cp "$archive" "$dir"});
  }
elsif($archive =~ /\.tgz|\.tar\.gz$/)
  {
  system(qq{/bin/rm -Rf "/tmp/$archive"});
  system(qq{/bin/mkdir -p "/tmp/$archive"});
  system(qq{/usr/bin/tar zxf "$archive" -C/tmp/$archive});
  
  $dir = `/usr/bin/find /tmp/$archive -mindepth 1 -maxdepth 1`;
  
  chomp $dir;
  }
elsif($archive =~ /\.tbz|\.tar\.bz$/)
  {
  system(qq{/bin/rm -Rf "/tmp/$archive"});
  system(qq{/bin/mkdir -p "/tmp/$archive"});
  system(qq{/usr/bin/tar jxf "$archive" -C/tmp/$archive});
  
  $dir = `/usr/bin/find /tmp/$archive -mindepth 1 -maxdepth 1`;
  
  chomp $dir;
  }
  
# Get optional arguments.
my $installPath;
my $sdk;
my $deployment;

GetOptions
  (
  'frameworkInstallPath=s' => \$installPath,
  'sdk=s' => \$sdk,
  'deploy=s' => \$deployment
  );
  
# Default to ~/Library/Frameworks
$installPath = File::Spec->join($ENV{HOME}, 'Library/Frameworks')
  if not $installPath;

my $nativeSDK = `/usr/bin/xcrun --show-sdk-path`;

chomp $nativeSDK;

# Setup the SDKROOT. Hopefully this will handle most situations.
if($sdk)
  {
  $ENV{SDKROOT} = `/usr/bin/xcrun --sdk $sdk --show-sdk-path`;
  
  chomp $ENV{SDKROOT};
  }

# Setup some command line arguments in case I need them.
my @arch;
my $minversion = '';

$deployment = `xcrun --show-sdk-version`
  if not $deployment;

chomp $deployment;

# Configure for iPhone.
if($sdk =~ /^iphoneos/i)
  {
  @arch = qw(armv7 armv7s arm64);

  if($deployment)
    {
    $minversion = sprintf('-miphoneos-version-min=%s', $deployment);
    
    $ENV{IPHONEOS_DEPLOYMENT_TARGET} = $deployment;
    }
  }
  
# Configure for iPhone simulator.
elsif($sdk =~ /^iphonesimulator/i)
  {
  @arch = qw(i386 x86_64);

  if($deployment)
    {
    $minversion = sprintf('-mios-simulator-version-min=%s', $deployment);

    $ENV{IPHONEOS_DEPLOYMENT_TARGET} = $deployment;
    }
  }
  
# Configure for MacOS X.
elsif($sdk =~ /^macosx/i)
  {
  my ($version) = $sdk =~ /^macosx(.+)$/i;
  
  @arch = qw(i386 x86_64)
    if $version && ($version < 10.9);
    
  if($deployment)
    {
    $minversion = sprintf('-mmacosx-version-min=%s', $deployment);

    $ENV{MACOSX_DEPLOYMENT_TARGET} = $deployment;
    }
  }

# Setup the isysroot command-line parameters and PATH, if necessary.
$ENV{PATH} = sprintf(
  '%s:%s:/usr/bin:/bin:/usr/sbin:/sbin',
  $ENV{SDKROOT},
  "/Applications/Xcode.app/Contents/Developer/usr/bin")
if $sdk && ($sdk =~ /^iphone/i);
  
# Get any other options.
my @args = @ARGV;

my $xargs = 
  {
  framework => $framework,
  source => $dir,
  id => $id,
  target => $installPath,
  sdk => $sdk,
  native => (@arch == 0),
  minversion => $minversion
  };

# Check to see if I have an SDK specified that is actually native.
if(not $xargs->{native})
  {
  $xargs->{native} = 1
    if $nativeSDK eq $ENV{SDKROOT};
  }

# Give me one iteration at least.
@arch = qw(x86_64)
  if not @arch;
  
# Repeat for each architecture.
foreach my $arch (@arch)
  {
  # Now hack up the version for non-native builds.
  $xargs->{version} = $version;

  $xargs->{version} .= sprintf('-%s-%s', $xargs->{sdk}, $arch)
    if not $xargs->{native};
  
  $ENV{CFLAGS} = "-arch $arch -isysroot $ENV{SDKROOT} $minversion"
    if not $xargs->{native};
  
  # Create the framework bones.
  createFramework($xargs);

  # Now build the UNIX project.
  buildProject($xargs, @args);

  # Turn the library into a framework.
  convertToFramework($xargs);

  # Install the final framework.
  installFramework($xargs);
  }
  
# Create framework bones.
sub createFramework
  {
  my $xargs = shift;

  my $frameworkPath = 
    sprintf('/tmp/%s.framework', $xargs->{framework});

  system(qq{/bin/rm -Rf "$frameworkPath"});
  
  my $frameworkVersionPath = 
    "$frameworkPath/Versions/" . $xargs->{version};

  mkpath("$frameworkVersionPath/Headers");
  mkpath("$frameworkVersionPath/Programs");
  mkpath("$frameworkVersionPath/Resources/Engish.lproj");
  mkpath("$frameworkVersionPath/unix/lib");

  # Now create some symbolically linked directories.
  symlink "../Headers", "$frameworkVersionPath/unix/include";
  symlink "../Programs", "$frameworkVersionPath/unix/bin";
  symlink "../Resources", "$frameworkVersionPath/unix/share";
  }

# Build a UNIX project in the unix directory of the framework.
sub buildProject
  {
  my $xargs = shift;
  my @args = @_;

  my $frameworkPath = sprintf('/tmp/%s.framework', $xargs->{framework});

  my $frameworkVersionPath = 
    "$frameworkPath/Versions/" . $xargs->{version};

  my $prefix = File::Spec->rel2abs("$frameworkVersionPath/unix");

  # Move into the directory.
  chdir $xargs->{source};

  # If there is a configure script, pass the args to it.
  if(-e 'configure')
    {
    system(qq{./configure --prefix=$prefix @args});

    # Make sure we get a fresh build.
    system("make clean");

    # Build using the provided arguments. If there was a configure script,
    # the argument list will be empty.
    system("make");

    # Now install into the framework.
    system("make install");
    }
  else
    {
    # Make sure we get a fresh build.
    system("make @args clean");

    # Build using the provided arguments. If there was a configure script,
    # the argument list will be empty.
    system("make @args");

    # Now install into the framework.
    system("make @args install");
    }

  chdir "..";
  }

# Turn a library into a framework.
sub convertToFramework
  {
  my $xargs = shift;
  my @args = @_;

  my $frameworkPath = sprintf('/tmp/%s.framework', $xargs->{framework});

  my $frameworkVersionPath = 
    "$frameworkPath/Versions/" . $xargs->{version};

  my $prefix = File::Spec->rel2abs("$frameworkVersionPath/unix");

  # Establish the library file and links to it.

  # First I have to find the library.
  my $library;

  # Scan through the UNIX output lib directory.
  opendir(DIR, "$prefix/lib");

  while (defined(my $file = readdir(DIR)))
    {
    # Skip parent and self directory entries.
    next
      if $file =~ /^\.\.?$/;

    # Delete .la files.
    unlink "$prefix/lib/$file"
      if $file =~ /\.la$/;

    # Skip anything that isn't a dynamic library.
    next
      if $file !~ /\.dylib$/;

    # Skip symbolic links.
    next
      if -l "$prefix/lib/$file";

    # Save the library. I assume there will only be one non-link library.
    $library = "$prefix/lib/$file";
    }

  closedir(DIR);

  if($library)
    {
    # Now create the library via hard link.
    link $library, "$frameworkVersionPath/" . $xargs->{framework};

    # Get rid of the old library.
    unlink $library;

    # Re-create the library as a symbolic link.
    $library = basename($library);

    symlink 
       "../../" . $xargs->{framework}, 
       "$frameworkVersionPath/unix/lib/$library";
    }
  }

# Install the framework
sub installFramework
  {
  my $xargs = shift;
  my @args = @_;

  my $frameworkPath = sprintf('/tmp/%s.framework', $xargs->{framework});

  my $frameworkVersionPath = 
    "$frameworkPath/Versions/" . $xargs->{version};
  
  my $targetPath = 
    sprintf('%s/%s.framework', $xargs->{target}, $xargs->{framework});
  
  my $targetVersionPath = "$targetPath/Versions/" . $xargs->{version};
  
  system(qq{/bin/mkdir -p "$targetPath/Versions"});
  
  system(qq{/bin/rm -Rf "$targetVersionPath"});

  system(qq{/bin/mv "$frameworkVersionPath" "$targetVersionPath"});

  # Create framework resources.
  createResources(
    $xargs->{framework}, $targetPath, $xargs->{version}, $xargs->{id});
  
  # Only setup the Current links if I am not cross-compiling.
  return
    if not $xargs->{native};
       
  # Create or update the Current links.
  setCurrentLink($targetPath);
  }
  
# Setup the Current links.
sub setCurrentLink
  {
  my $frameworkPath = shift;

  # Should I update the current link?
  opendir(DIR, "$frameworkPath/Versions");

  my $latestVersion;
  
  while (defined(my $existingVersion = readdir(DIR)))
    {
    # Skip parent and self directory entries.
    next
      if $existingVersion =~ /^\.\.?$/;

    $latestVersion = maxVersion($existingVersion, $latestVersion);
    }

  closedir(DIR);

  # Create the current symbolic linked directory.
  unlink "$frameworkPath/Versions/Current";

  unlink "$frameworkPath/Headers";
  unlink "$frameworkPath/Programs";
  unlink "$frameworkPath/Resources";
  unlink "$frameworkPath/unix";
  unlink "$frameworkPath/$framework";

  symlink $latestVersion, "$frameworkPath/Versions/Current";

  symlink "Versions/Current/Headers", "$frameworkPath/Headers";
  symlink "Versions/Current/Programs", "$frameworkPath/Programs";
  symlink "Versions/Current/Resources", "$frameworkPath/Resources";
  symlink "Versions/Current/unix", "$frameworkPath/unix";

  # Finally update the top-level library link.
  symlink "Versions/Current/$framework", "$frameworkPath/$framework";
  }

# Find the maximum of two version number strings.
sub maxVersion
  {
  my $value1 = shift;
  my $value2 = shift;

  my @value1 = $value1 =~ /(\d+)/g;
  my @value2 = $value2 =~ /(\d+)/g;

  my $index = 0;

  my @max = @value1;

  while(1)
    {
    last
      if not defined $value1[$index];
    
    last
      if not defined $value2[$index];

    if($value1[$index] > $value2[$index])
      {
      @max = @value1;
    
      last;
      }
    elsif($value2[$index] > $value1[$index])
      {
      @max = @value2;
    
      last;
      }
    else
      {
      ++$index;
    
      next;
      }
    }
  
  my $max = join('.', @max);

  return $max;
  }
  
# Create framework resources.
sub createResources
  {
  my $frameworkName = shift;
  my $frameworkVersionPath = shift;
  my $version = shift;
  my $id = shift;

  # Almost done - create the Info.plist file.

  open(OUT, ">$frameworkVersionPath/Resources/Info.plist");

  print OUT getPlist($frameworkName, $version, $id);

  close(OUT);

  # Finally, look for a license file.
  my $license;

  # Scan through the source directory.
  opendir(DIR, "$dir");

  while(defined(my $file = readdir(DIR)))
    {
    # Skip parent and self directory entries.
    next
      if $file =~ /^\.\.?$/;

    # Get the GNU-stye COPYING file.
    $license = $file
      if $file =~ /^COPYING$/;

    $license = $file
      if $file =~ /license/i;

    last
      if $license;
    }

  closedir(DIR);

  copy
    "$dir/$license", "$frameworkVersionPath/Resources/License.txt"
    if $license;
  }

# Construct and return a plist file.
sub getPlist
  {
  my $frameworkName = shift;
  my $version = shift;
  my $id = shift;

  my $plist = << "EOF";
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>English</string>
	<key>CFBundleExecutable</key>
	<string>$frameworkName</string>
	<key>CFBundleGetInfoString</key>
	<string>$framework $version</string>
	<key>CFBundleIdentifier</key>
	<string>$id</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$frameworkName</string>
	<key>CFBundlePackageType</key>
	<string>FMWK</string>
	<key>CFBundleShortVersionString</key>
	<string>$version</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>$frameworkName $version</string>
</dict>
</plist>
EOF

  return $plist;
  }

sub mkpath
  {
  my $dir = shift;

  system(qq{/bin/mkdir -p "$dir"});
  }

# Print usage messages.
sub usage
  {
  my $message = << "EOF";
Usage: lib2framework <framework> <id> <version> <dir> [options]

  where options are:
    --frameworkInstallPath=/path/to/install/location
    --sdk=<SDK in xcrun nomenclature. e.g. macosx, iphonesimulator6.1, etc.>
    --deploy=<minimum OS version>
    
  Remaining options are passed to configure script.
EOF

  return $message;
  }
  